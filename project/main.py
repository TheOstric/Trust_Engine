from flask import Flask, render_template, redirect, url_for, request, flash
from flask_mail import Mail, Message
from textmagic.rest import TextmagicRestClient
from socket import socket, AF_INET, SOCK_DGRAM
import os
import json
import pyotp
import hashlib
import socket
import pipes
import portalocker
import trust_engine
import concurrent.futures

risk_level = 0
risk = ''
ip = ''
host = ''
data = ''
r = ''
confirmed = False
db_item = {}
username = "your textmagic username"
token = "your textmagic token"
client = TextmagicRestClient(username, token)
app = Flask(__name__)

random_key = os.urandom(16)
app.config.update(dict(
    DEBUG = True,
    SECRET_KEY = str(random_key),
    MAIL_SERVER = "your mail server",
    MAIL_PORT = 587,
    MAIL_USE_TLS = True,
    MAIL_USE_SSL = False,
    MAIL_USERNAME = "your email",
    MAIL_PASSWORD = "your email password",
))
hfun = 'sha256'
mail = Mail(app)

if os.path.exists('./auth.json') and os.path.getsize('./auth.json') > 0:
    with open('./auth.json','r') as json_file:
        db_item = json.load(json_file)

def check_credentials(email, password):
    if email not in db_item: 
        return False
    else:
        salt = db_item.get(email).get('salt')
        hashed = db_item.get(email).get('hashed')
        shashed = hashlib.pbkdf2_hmac(hfun, password.encode(), salt.encode(), 100000)
        if hashed == shashed.hex():
            return True
        else:
            False

def identify_level(risk_host, risk_user):
    if risk_host == 'Low' and risk_user == 0:
        return 0
    
    if risk_host == 'Low' and risk_user == 1:
        return 1
    
    if risk_host == 'Medium' and risk_user == 0:
        return 1

    if risk_host == 'Medium' and risk_user == 1:
        return 2

    if risk_host == 'High' and risk_user == 0:
        return 2

    if risk_host == 'High' and risk_user == 1:
        return 3


@app.route("/")
def home():
    global r, host, ip, confirmed
    print('CONFIRMED: ' + str(confirmed))
    if confirmed == False:
        with open('pipefile','r') as file:
            portalocker.lock(file, portalocker.LOCK_EX)
            for line in file:
                p = line
            portalocker.unlock(file)
        data = p.split()
        print(data)
        risk = data[3]
        ip = data[2]
        r = data[0] + ' ' + data[1] + ' ' + data[2]
        host = data[1]

        return render_template("index.html")
    else:
        return redirect('https://' + host)

@app.route("/pass_auth")
def pass_auth():
    return render_template("pass_auth.html")

@app.route('/pass_auth', methods=['POST'])
def login():
    global r, host, ip
    email = request.form.get('email')
    password = request.form.get('password')
    print(check_credentials(email,password))
    if True:
        #risk_level = identify_level(risk,0)
        if risk_level == 0:
            t = trust_engine.TrustEngine()
            with concurrent.futures.ThreadPoolExecutor() as executor:
                future = executor.submit(t.run,r)
                print(future.result())
                if future.result() == 'Allowed':
                    confirmed = True
                    return render_template('authorized.html')
            
        elif risk_level == 1:
            return redirect('http://127.0.0.1:5000/pass_auth/2fa')
        elif risk_level == 2:
            return redirect('http://www.inps.it/pass_auth/email_a')
    else:
        flash('Please check your login details and try again.',"danger")
        return redirect('http://www.inps.it/pass_auth')

@app.route('/pass_auth/2fa')
def login_email():
    #generating random token for authentication
    token = pyotp.random_base32()

    msg = Message('Authentication mail with token',sender = 'sending mail address', recipients=['destination mail address'])
    link = url_for('confirm',external = True)
    msg.body = token
    mail.send(msg)

    return render_template("login_email.html", secret = token)

@app.route('/pass_auth/2fa', methods=["POST", "GET"])
def login_email_auth():
    #getting secret Token used by user
    token = request.form.get('secret')
    #getting OTP generated by GoogleAuth
    otp = request.form.get('otp')
    if otp == '':
        flash("Please, submit a not empty otp","danger")
        return redirect(url_for("login_email"))
    
    otp_check = int(otp)

    #verifying OTP with PyOTP
    if pyotp.TOTP(token).verify(otp_check):
        #OTP is valid
        flash("The submitted OTP token is valid","success")
        return redirect('https://' + host)
    else:
        #OTP is invalid
        flash("The OTP submitted token is invalid","danger")
        return redirect(url_for("login_email"))

@app.route('/pass_auth/email_a')
def login_sms():
    msg = Message('Authentication mail',sender = 'sending mail address', recipients=['destination mail address'])
    link = url_for('confirm',external = True)
    msg.body = 'Please, click on the following link and then check your phone for the authentication code: {}'.format(link)
    mail.send(msg)

    flash("Check your email and use the authentication link","success")
    return render_template('pass_auth.html')

@app.route('/pass_auth/sms_a')
def confirm():
    msg = client.messages.create(phones= "destination phone number", text = "12345")
    return render_template("login_email.html")

if __name__ == '__main__':
    app.run(debug=True)
